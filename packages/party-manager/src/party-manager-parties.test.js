//
// Copyright 2019 DXOS.org
//

import debug from 'debug';
import waitForExpect from 'wait-for-expect';

import { Keyring, KeyType, codec, createAuthMessage } from '@dxos/credentials';
import { createKeyPair, keyToBuffer, randomBytes, sign, verify, SIGNATURE_LENGTH } from '@dxos/crypto';

import { InviteDetails, InviteType } from './invite-details';
import { TestNetworkNode } from './testing/test-network-node';
import { checkReplication, checkPartyInfo, createTestParty, destroyNodes, checkContacts } from './testing/test-common';

// eslint-disable-next-line no-unused-vars
const log = debug('dxos:party-manager:test');

test('Create a party with 2 Identities each having one device (signature invitation)', async () => {
  const keyringA = new Keyring();
  await keyringA.createKeyRecord({ type: KeyType.IDENTITY });
  const keyringB = new Keyring();
  await keyringB.createKeyRecord({ type: KeyType.IDENTITY });

  const nodeA = new TestNetworkNode(keyringA);
  await nodeA.initialize({ identityDisplayName: 'IdentityA', deviceDisplayName: 'Device1-A' });
  const nodeB = new TestNetworkNode(keyringB);
  await nodeB.initialize({ identityDisplayName: 'IdentityB', deviceDisplayName: 'Device1-B' });
  const nodes = [nodeA, nodeB];

  // Create the Party.
  const party = await nodeA.partyManager.createParty();

  // In real life this would be a keypair associated with BotFactory.
  const keyPair = createKeyPair();

  // Provided by Greeter initiator.
  const greeterSecretValidator = async (invitation, secret) => {
    const signature = secret.slice(0, SIGNATURE_LENGTH);
    const message = secret.slice(SIGNATURE_LENGTH);
    return verify(message, signature, keyPair.publicKey);
  };

  // Issue the invitation on nodeA.
  const invitationDescriptor = await nodeA.partyManager.inviteToParty(party.publicKey,
    new InviteDetails(InviteType.INTERACTIVE, { secretValidator: greeterSecretValidator }));

  // The `secret` Buffer is composed of the signature (fixed length) followed by the message (variable length).
  const inviteeSecretProvider = async () => {
    const message = randomBytes(32);
    const signature = sign(message, keyPair.secretKey);
    const secret = Buffer.alloc(signature.length + message.length);
    signature.copy(secret);
    message.copy(secret, signature.length);
    return secret;
  };

  // And then redeem it on nodeB.
  await nodeB.partyManager.joinParty(invitationDescriptor, inviteeSecretProvider);

  await checkReplication(party.publicKey, nodes);
  await checkPartyInfo(party.publicKey, nodes);
  await checkContacts(nodes);
  await destroyNodes(nodes);
});

test('Create a party with 2 Identities each having one device (publicKey + keychain signature)', async () => {
  const keyringA = new Keyring();
  await keyringA.createKeyRecord({ type: KeyType.IDENTITY });
  const keyringB = new Keyring();
  await keyringB.createKeyRecord({ type: KeyType.IDENTITY });

  const nodeA = new TestNetworkNode(keyringA);
  await nodeA.initialize({ identityDisplayName: 'IdentityA', deviceDisplayName: 'Device1-A' });
  const nodeB = new TestNetworkNode(keyringB);
  await nodeB.initialize({ identityDisplayName: 'IdentityB', deviceDisplayName: 'Device1-B' });
  const nodes = [nodeA, nodeB];

  // Create the Party.
  const party = await nodeA.partyManager.createParty();

  // The PublicKey of the contact we wish to invite.
  const contactKey = nodeB.partyManager.identityManager.publicKey;

  // This function executes on the Greeter to validate credentials presented by the invited contact.
  const greeterSecretValidator = async (invitation, secret) => {
    const { payload: authMessage } = codec.decode(secret);
    const invitationID = keyToBuffer(invitation.id);

    // Create a Keyring containing only the PublicKey of the contact we invited. Only a message signed by
    // by the matching private key, or a KeyChain which traces back to that key, will be verified.
    const keyring = new Keyring();
    await keyring.addPublicKey({
      publicKey: contactKey,
      type: KeyType.IDENTITY,
      trusted: true,
      own: false
    });

    return keyring.verify(authMessage) && invitationID.equals(authMessage.signed.payload.partyKey);
  };

  // Issue the invitation on nodeA.
  const invitationDescriptor = await nodeA.partyManager.inviteToParty(party.publicKey,
    new InviteDetails(InviteType.INTERACTIVE, { secretValidator: greeterSecretValidator }));

  // This function executes on the invitee. It provides an Auth message which has been signed by the local
  // device key, with its KeyChain leading back to the Identity PublicKey.
  const inviteeSecretProvider = async () => {
    const authMessage = createAuthMessage(keyringB,
      // Use the invitation ID as the "partyKey" within this context. Since the invitation ID is randomly generated by
      // the Greeter, using it as the target "party" provides a reasonable confidence that this message was signed in
      // response to this particular invitation without requiring additional challenges.
      invitationDescriptor.invitation,
      nodeB.partyManager.identityManager.keyRecord,
      nodeB.partyManager.identityManager.deviceManager.keyChain);

    return codec.encode(authMessage);
  };

  // And then redeem it on nodeB.
  await nodeB.partyManager.joinParty(invitationDescriptor, inviteeSecretProvider);

  await checkReplication(party.publicKey, nodes);
  await checkPartyInfo(party.publicKey, nodes);
  await checkContacts(nodes);
  await destroyNodes(nodes);
});

test('Create a party with 3 identities each having one device (secret invitation)', async () => {
  const { party, nodes } = await createTestParty(3);
  await checkReplication(party.publicKey, nodes);
  await checkPartyInfo(party.publicKey, nodes);
  await checkContacts(nodes);
  await destroyNodes(nodes);
});

test('Check subscribe/unsubscribe', async (done) => {
  const { party: { publicKey: partyKey }, nodes } = await createTestParty(3);
  await checkReplication(partyKey, nodes);
  await checkPartyInfo(partyKey, nodes);
  await checkContacts(nodes);

  const [nodeA, nodeB, nodeC] = nodes;
  await nodeA.partyManager.unsubscribe(partyKey);
  await waitForExpect(() => {
    const party = nodeA.partyManager.getParty(partyKey);
    expect(party.isOpen()).toBe(false);
  }, 1000);

  // Replication should keep working between B and C.
  await checkReplication(partyKey, [nodeB, nodeC]);

  // It should not work to and from A.
  try {
    await checkReplication(partyKey, nodes);
    done.fail();
  } catch (err) {
    expect(err).toBeInstanceOf(Error);
  }

  // Re-subscribe.
  await nodeA.partyManager.subscribe(partyKey);

  // Now it should work again.
  await waitForExpect(() => {
    const party = nodeA.partyManager.getParty(partyKey);
    expect(party.isOpen()).toBe(true);
  }, 1000);
  await checkReplication(partyKey, nodes);

  await destroyNodes(nodes);
  done();
});

test('Create a party with 2 Identities each having one device (PartInvitationMessage invite)', async () => {
  const keyringA = new Keyring();
  await keyringA.createKeyRecord({ type: KeyType.IDENTITY });
  const keyringB = new Keyring();
  await keyringB.createKeyRecord({ type: KeyType.IDENTITY });

  const nodeA = new TestNetworkNode(keyringA);
  await nodeA.initialize({ identityDisplayName: 'IdentityA', deviceDisplayName: 'Device1-A' });
  const nodeB = new TestNetworkNode(keyringB);
  await nodeB.initialize({ identityDisplayName: 'IdentityB', deviceDisplayName: 'Device1-B' });
  const nodes = [nodeA, nodeB];

  // Create the Party.
  const party = await nodeA.partyManager.createParty();

  // The PublicKey of the contact we wish to invite.
  const contactKey = nodeB.partyManager.identityManager.publicKey;

  const invitationDescriptor = await nodeA.partyManager.inviteToParty(party.publicKey,
    new InviteDetails(InviteType.OFFLINE_KEY, { publicKey: contactKey }));

  await waitForExpect(() => {
    expect(party.getInvitation(invitationDescriptor.invitation)).toBeTruthy();
  });

  // This function executes on the invitee. It provides an Auth message which has been signed by the local
  // device key, with its KeyChain leading back to the Identity PublicKey.
  const inviteeSecretProvider = (info) => codec.encode(createAuthMessage(keyringB, info.id.value,
    nodeB.partyManager.identityManager.keyRecord,
    nodeB.partyManager.identityManager.deviceManager.keyChain,
    null, info.authNonce.value)
  );

  // And then redeem it on nodeB.
  await nodeB.partyManager.joinParty(invitationDescriptor, inviteeSecretProvider);

  await checkReplication(party.publicKey, nodes);
  await checkPartyInfo(party.publicKey, nodes);
  await checkContacts(nodes);
});
