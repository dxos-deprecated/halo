//
// Copyright 2019 Wireline, Inc.
//

syntax = "proto3";

package dxos.credentials.greet;

import "./party.proto";
import "google/protobuf/any.proto";
import "google/protobuf/wrappers.proto";

//
// Greeting protocol:
//
//  Two nodes: Greeter which acts like a "server" and Invitee which acts like a "client".
//  All interactions are request/response with the request always sent by the Invitee and the response always
//  sent by the Invitee.
//
//  1) An invitation is generated for the Invitee with a unique ID, known to the Greeter.
//  2) The Invitee connects to the Greeter over an *open* Topic, using the invitation ID as their peer ID.
//     This is NOT the Topic of the Party they wish to join, it is one used for Greeting.
//  3) The Invitee sends a Command message of type BEGIN. This triggers creation or retrieval
//     of an auth secret for the rest of the process. This secret is normally communicated out-of-band
//     (eg, voice, IM, etc.).
//     The Greeter responds with a BeginResponse message, indicating the Invitee should proceed to the next step:
//  4) The Invitee sends a Command message of type HANDSHAKE which includes their secret (eg, PIN).
//  5) The Greeter validates the contents (it's genuine, hasn't already been redeemed, the secret matches, etc.)
//  6) The Greeter returns a HandshakeResponse message with the Party public key and challenge nonce.
//  7) The Invitee generates one or more AdmitKey and AdmitFeed messages, appends the nonce then signs, wrapped in a
//     SignedMessage.
//  8) The Invitee then sends that SignedMessage in a Command message of type NOTARIZE.
//  9) The Greeter checks authentication credentials presented, validates the SignedMessage signature and nonce.
//     If all the checks pass then the Admit messages may be published on the Greeter's feed for the target party.
// 10) The Greeter marks the invitation as redeemed, so that it cannot be used again for any other commands.
// 11) The Greeter sends all the Party construction messages to the Invitee in a NotarizeResponse message.
//     The Invitee uses these to construct its view of the Party membership, necessary to participate in mutual
//     authentication for this party's feed replication.
// 12) The Invitee sends the Greeter a FINISH command to acknowledge receipt.

//
// A Greeter command. We currently have two commands, 'HANDSHAKE' and 'NOTARIZE'.
//
message Command {
  enum Type {
    BEGIN = 0;
    HANDSHAKE = 1;
    NOTARIZE = 2;
    FINISH = 3;
    CLAIM = 10;
  }

  Type command = 1;

  // Auth secret (PIN, hash, etc.).
  bytes secret = 2;

  // TODO(burdon): These seem to be signed messages? In which case we already know the type.
  // TODO(dboreham): static typing of contained messages is not yet supported, change from any when it is.
  // Parameters to the command.
  repeated google.protobuf.Any params = 10;
};

//
// Info is optional, and not needed for very simple schemes like using a PIN, but more complicated scenarios schemes
// might need to communicate additional info in the response (eg, which auth scheme is required).
//
message BeginResponse {
  google.protobuf.Any info = 1;
}

//
// The next command is 'HANDSHAKE', the invitee sends the `secret` for authentication, and if successful, the
// Greeter returns the `partyKey` and a `nonce` which the invitee will need to use for the Party credential messages.
//
message HandshakeResponse {

  // Random bytes which must be included in the signed portion of messages submitted in a 'NOTARIZE' command
  // (proving ownership of the keys in question).
  bytes nonce = 1;

  // The public key of the party.
  bytes partyKey = 2;
};

//
// The 'NOTARIZE' command is the final command during Greeting, and takes an array of SignedMessages which the invitee
// would like added to the Party. The standard case would be a message admitting a Pseudonym key, a DevicePseudonym
// key, and a Feed.
//
message NotarizeResponse {

  // A copy of each of the messages as written to the Party (now in an Envelope signed by the Greeter) and the Feed
  // and key hints necessary to bootstrap the invitee into the Party.
  repeated google.protobuf.Any copies = 1;

  // Feed and key hints necessary to bootstrap the invitee into the Party.
  repeated KeyHint hints = 2;
};

//
// Feed and key hints are required by the invitee, because even though the Party members now trust it, it does not trust
// them. Until it has a chance to replicate, it cannot construct its own understanding of the Party from party.*
// messages, but neither can it replicate unless it trusts its peers. The Hints break this cycle by providing an
// initial set of keys and Feeds to trust.
//
message KeyHint {
  // TODO(telackey): These should be changed to be the full set of signed party messages, so the recipient can build
  // and verify the party structure just as it would if it had obtained them from the feeds.
  bytes publicKey = 1;
  KeyType type = 2;
}


//
//
//
message ClaimResponse {
  bytes id = 1;
  bytes rendezvousKey = 2;
}
