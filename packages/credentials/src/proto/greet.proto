//
// Copyright 2019 Wireline, Inc.
//

syntax = "proto3";

package dxos.credentials.greet;

import "./party.proto";
import "google/protobuf/any.proto";

//
// Greeting protocol:
//
//  Two nodes: Greeter which acts like a "server" and Invitee which acts like a "client".
//  All interactions are request/response with the request always sent by the Invitee and the response always
//  sent by the Invitee.
//
//  1) An invitation is generated for the Invitee with a unique ID, known to the Greeter.
//  2) The Invitee connects to the Greeter over an *open* Topic, using the invitation ID as their peer ID.
//     This is NOT the Topic of the Party they wish to join, it is one used for Greeting.
//  3) The Invitee sends a Command message of type PRESENT. This triggers creation or retrieval
//     of an auth secret for the rest of the process. This secret is normally communicated out-of-band
//     (eg, voice, IM, etc.).
//     The Greeter responds with a PresentResponse message, indicating the Invitee should proceed to the next step:
//  4) The Invitee sends a Command message of type NEGOTIATE which includes their secret (eg, PIN).
//  5) The Greeter validates the contents (it's genuine, hasn't already been redeemed, the secret matches, etc.)
//  6) The Greeter returns a NegotiateResponse message with the Party public key and challenge nonce.
//  7) The Invitee generates one or more AdmitKey and AdmitFeed messages, appends the nonce then signs, wrapped in a
//     SignedMessage.
//  8) The Invitee then sends that SignedMessage in a Command message of type SUBMIT.
//  9) The Greeter checks authentication credentials presented, validates the SignedMessage signature and nonce.
//     If all the checks pass then the Admit messages may be published on the Greeter's feed for the target party.
// 10) The Greeter marks the invitation as redeemed, so that it cannot be used again for any other commands.
// 11) The Greeter sends all the Party construction messages to the Invitee in a SubmitResponse message.
//     The Invitee uses these to construct its view of the Party membership, necessary to participate in mutual
//     authentication for this party's feed replication.
// 12) The Invitee sends the Greeter a FINISH command to acknowledge receipt.

//
// A Greeter command. We currently have two commands, 'NEGOTIATE' and 'SUBMIT'.
//
message Command {
  enum Type {
    PRESENT = 0;
    NEGOTIATE = 1;
    SUBMIT = 2;
    FINISH = 3;
    INTRO = 10;
  }

  Type command = 1;

  // Auth secret (PIN, hash, etc.).
  bytes secret = 2;

  // TODO(burdon): These seem to be signed messages? In which case we already know the type.
  // TODO(dboreham): static typing of contained messages is not yet supported, change from any when it is.
  // Parameters to the command.
  repeated google.protobuf.Any params = 10;
};

message IntroResponse {
  bytes rendezvousKey = 1;
}

//
// Info is optional, and not needed for very simple schemes like using a PIN, but more complicated scenarios schemes
// might need to communicate additional info in the response (eg, which auth scheme is required).
//
message PresentResponse {
  google.protobuf.Any info = 1;
}

//
// The initial command is 'NEGOTIATE', which gives an opportunity for both ends to communicate any additional details
// or requirements to each other.
//
message NegotiateResponse {

  // Random bytes which must be included in the signed portion of messages submitted in a 'SUBMIT' command
  // (proving ownership of the keys in question).
  bytes nonce = 1;

  // The public key of the party.
  bytes partyKey = 2;
};

//
// The 'SUBMIT' command is the final command during Greeting, and takes an array of SignedMessages which the invitee
// would like added to the Party. The standard case would be a message admitting a Pseudonym key, a DevicePseudonym
// key, and a Feed.
//
message SubmitResponse {

  // A copy of each of the messages as written to the Party (now in an Envelope signed by the Greeter) and the Feed
  // and key hints necessary to bootstrap the invitee into the Party.
  repeated google.protobuf.Any copies = 1;

  // Feed and key hints necessary to bootstrap the invitee into the Party.
  repeated KeyHint hints = 2;
};

//
// Feed and key hints are required by the invitee, because even though the Party members now trust it, it does not trust
// them. Until it has a chance to replicate, it cannot construct its own understanding of the Party from party.*
// messages, but neither can it replicate unless it trusts its peers. The Hints break this cycle by providing an
// initial set of keys and Feeds to trust.
//
message KeyHint {
  // TODO(telackey): These should be changed to be the full set of signed party messages, so the recipient can build
  // and verify the party structure just as it would if it had obtained them from the feeds.
  bytes publicKey = 1;
  KeyType type = 2;
}


//
// An Invitation message that can be written to the Party so that any existing Party member can authenticate
// the invitee and perform greeting. This message must be written within a SignedMessage signed by the key (or KeyChain)
// of listed as the `issuer`. The invitee must authenticate themselves to the Greeter with Auth messages signed by
// the key (or KeyChain) of listed in the `invitee` field.
//
message Invitation {
  bytes id = 1;           // A unique ID for this Invitation.
  bytes partyKey = 2;     // The public key of the Party for which this Invitation is valid.
  bytes issuerKey = 3;       // The public key of the Party member issuing this invitation.
  bytes inviteeKey = 4;      // The public key of the non-member that is being invited to join the Party.
}
